---
lesson_id: "04-workflows"
lesson_title: "Workflows"
source_dir: "reference-course/mastra/04-workflows"
step_count: 22
---

<!-- STEP:01 -->
## Step 01: Introduction to Workflows

# Introduction to Workflows

Welcome to the fourth lesson of the Mastra course! In this lesson, you'll learn about Mastra Workflows - a powerful way to orchestrate complex sequences of operations.

## What are Workflows?

Workflows in Mastra let you chain together multiple operations in a predictable, type-safe manner. Think of them as a recipe that breaks down complex tasks into smaller, manageable steps.

Instead of writing one big function that does everything, workflows let you:

- Break complex operations into smaller, reusable steps
- Define clear inputs and outputs for each step
- Chain steps together with automatic data validation
- Handle errors gracefully at each step

## Simple Example

Without workflows, you might write:

```typescript
async function processContent(text: string) {
  // All logic in one function - hard to test and reuse
  const validated = validateText(text);
  const enhanced = enhanceText(validated);
  const summarized = summarizeText(enhanced);
  return summarized;
}
```

With workflows, the same logic becomes modular and reusable with tracing built in at every step.

```typescript
export const contentWorkflow = createWorkflow({...})
  .then(validateStep)
  .then(enhanceStep)
  .then(summarizeStep)
  .commit();
```

## What You'll Build

In this lesson, you'll create a content processing workflow that validates, enhances, and summarizes text content using multiple connected steps.

Let's start by understanding the basic building blocks!

## Step Quiz
**Questions**
1) What is the main purpose of a workflow in this lesson?
**Answers**
1) To orchestrate multiple steps into a reliable multi-stage process.

<!-- STEP:02 -->
## Step 02: Understanding Steps

# Understanding Steps

Steps are the building blocks of workflows. Each step is a self-contained unit that takes some input, processes it, and produces an output.

## What is a Step?

A step has three main parts:

1. **Input Schema** - what data it expects to receive
2. **Output Schema** - what data it will produce
3. **Execute Function** - the logic that transforms input to output

## Step Structure

Every step follows this pattern:

```typescript
const myStep = createStep({
  id: "unique-step-name",
  description: "What this step does",
  inputSchema: z.object({
    // Define expected input structure
  }),
  outputSchema: z.object({
    // Define output structure
  }),
  execute: async ({ inputData }) => {
    // Your logic here
    return {
      // Return data matching output schema
    };
  },
});
```

## Why Use Schemas?

Schemas provide several benefits:

- **Type Safety**: TypeScript knows exactly what data flows between steps
- **Runtime Validation**: Invalid data is caught immediately with helpful error messages
- **Documentation**: Schemas serve as living documentation of your workflow
- **Debugging**: Clear contracts make it easy to identify issues

## Key Benefits

- **Reusable**: Steps can be used in multiple workflows
- **Testable**: Each step can be tested in isolation
- **Composable**: Steps can be combined in different ways
- **Reliable**: Schemas catch data flow issues early
- **Traceable**: Every step is traced so you can see the flow of data

Next, you'll create your first step!

## Step Quiz
**Questions**
1) What does a step define in a workflow?
**Answers**
1) A unit of work with input/output schemas and an execute function.

<!-- STEP:03 -->
## Step 03: Creating Your First Step

# Creating Your First Step

Let's create your first workflow step! We'll build a step that validates text content.

## Setting Up

First, create a new file for your workflow in the `src/mastra/workflows` directory. Let's name this file `content-workflow.ts`

## Creating a Validation Step

Add this code to your workflow file:

```typescript
import { createStep } from "@mastra/core/workflows";
import { z } from "zod";

const validateContentStep = createStep({
  id: "validate-content",
  description: "Validates incoming text content",
  inputSchema: z.object({
    content: z.string().min(1, "Content cannot be empty"),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    isValid: z.boolean(),
  }),
  execute: async ({ inputData }) => {
    const { content, type } = inputData;

    const wordCount = content.trim().split(/\s+/).length;
    const isValid = wordCount >= 5; // Minimum 5 words

    if (!isValid) {
      throw new Error(`Content too short: ${wordCount} words`);
    }

    return {
      content: content.trim(),
      type,
      wordCount,
      isValid,
    };
  },
});
```

## Understanding the Code

- **ID**: Unique identifier for this step
- **Input Schema**: Expects `content` (string) and optional `type`
- **Output Schema**: Returns content, type, word count, and validation status
- **Execute**: Contains the validation logic

Your first step is ready! Next, you'll test it to make sure it works correctly.

## Step Quiz
**Questions**
1) What does the validation step produce beyond the content itself?
**Answers**
1) Metadata like wordCount and an isValid flag.

<!-- STEP:04 -->
## Step 04: Creating a Second Step

# Creating a Second Step

Now let's create a second step that enhances the validated content with metadata.

## The Enhancement Step

Add this step to your workflow file:

```typescript
const enhanceContentStep = createStep({
  id: "enhance-content",
  description: "Adds metadata to validated content",
  inputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    isValid: z.boolean(),
  }),
  outputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    metadata: z.object({
      readingTime: z.number(),
      difficulty: z.enum(["easy", "medium", "hard"]),
      processedAt: z.string(),
    }),
  }),
  execute: async ({ inputData }) => {
    const { content, type, wordCount } = inputData;

    // Calculate reading time (200 words per minute)
    const readingTime = Math.ceil(wordCount / 200);

    // Determine difficulty based on word count
    let difficulty: "easy" | "medium" | "hard" = "easy";
    if (wordCount > 100) difficulty = "medium";
    if (wordCount > 300) difficulty = "hard";

    return {
      content,
      type,
      wordCount,
      metadata: {
        readingTime,
        difficulty,
        processedAt: new Date().toISOString(),
      },
    };
  },
});
```

## Notice the Input Schema

The input schema of this step matches the output schema of the previous step. This is important for chaining steps together!

Your second step is ready! Next, you'll learn how to chain these steps together into a complete workflow.

## Step Quiz
**Questions**
1) Why does the enhancement step include additional metadata?
**Answers**
1) To enrich the content with computed fields like reading time and difficulty.

<!-- STEP:05 -->
## Step 05: Chaining Steps Together

# Chaining Steps Together

Now you'll learn how to chain your steps together to create a complete workflow.

## Creating the Workflow

Add this workflow definition to your file:

```typescript
import { createWorkflow } from "@mastra/core/workflows";

export const contentWorkflow = createWorkflow({
  id: "content-processing-workflow",
  description: "Validates and enhances content",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    metadata: z.object({
      readingTime: z.number(),
      difficulty: z.enum(["easy", "medium", "hard"]),
      processedAt: z.string(),
    }),
  }),
})
  .then(validateContentStep)
  .then(enhanceContentStep)
  .commit();
```

## Understanding the Workflow

- **Input Schema**: Defines what data the workflow expects
- **Output Schema**: Defines what the workflow will return
- **Steps**: Chained using `.then()` in the order they should execute
- **Commit**: Finalizes the workflow definition

## How Data Flows

1. Workflow receives input matching the input schema
2. First step processes input and outputs validated data
3. Second step receives the first step's output as its input
4. Workflow returns the final step's output

## Schema Validation

The workflow automatically validates:

- Input data matches the workflow's input schema
- Each step's output matches the next step's input schema
- Final output matches the workflow's output schema

Your workflow is now ready to run! Next, you'll test the complete workflow.

## Step Quiz
**Questions**
1) How are steps chained in the workflow?
**Answers**
1) Outputs of one step feed into the inputs of the next step via schemas.

<!-- STEP:06 -->
## Step 06: Registering with Mastra

# Registering with Mastra

Now you'll register your workflow with the main Mastra instance so you can use it alongside agents and tools.

## Updating Your Mastra Configuration

Open your `src/mastra/index.ts` file and add your workflow:

```typescript
// Import your workflow
import { contentWorkflow } from "./workflows/content-workflow";

export const mastra = new Mastra({
  // Register your workflow here
  workflows: {
    contentWorkflow,
  },
  // ...Existing code
});
```

Note: You may already have workflows registered, in which case, this workflow should be added to the workflows object.

Your workflow is now registered with Mastra! Next, you'll learn how to use it in the playground.

## Step Quiz
**Questions**
1) Why register the workflow with Mastra?
**Answers**
1) So it appears in the runtime/playground and can be executed.

<!-- STEP:07 -->
## Step 07: Using the Playground

# Using the Playground

The Mastra Playground provides a visual interface to test and run your workflows. Let's see your workflow in action!

## Starting the Development Server

Start your Mastra development server using the `mastra dev` command. If you are using npm the command is:

```bash
npm run dev
```

You should see output like:

```bash
üöÄ Mastra Dev Server starting...
üìä Studio available at: http://localhost:4111
```

## Accessing Workflows in Playground

1. Open your browser and go to `http://localhost:4111`
2. Click on "Workflows" in the navigation
3. You should see your `contentWorkflow` listed

## Testing Your Workflow

1. Click on your `contentWorkflow`
2. You'll see an input form based on your workflow's input schema
3. Enter some test content in the form:

```json
{
  "content": "Machine learning is revolutionizing healthcare by enabling faster diagnoses and personalized treatments.",
  "type": "article"
}
```

4. Click "Run Workflow"
5. Watch the execution progress and see the results

## Understanding the Interface

The playground shows you:

- **Input Schema**: What data your workflow expects
- **Execution Progress**: Real-time updates as steps complete
- **Output**: The final result from your workflow
- **Execution Time**: How long the workflow took to run

## Benefits of the Playground

- **Visual Testing**: Easy way to test workflows without writing code
- **Schema Validation**: Automatic form generation from your schemas
- **Real-time Feedback**: See exactly what's happening during execution
- **Easy Debugging**: Quickly test different inputs and view traces from workflow runs

Great! You can now visually test your workflow. Next, you'll learn how to run workflows programmatically.

## Step Quiz
**Questions**
1) What is the playground used for in this lesson?
**Answers**
1) To run and inspect workflow executions interactively.

<!-- STEP:08 -->
## Step 08: Running Workflows Programmatically

# Running Workflows Programmatically

Learn how to execute your workflows from code, which is essential for integrating them into applications.

## Creating a Workflow Runner

Create a new file to test programmatic execution:

```typescript
// src/run-workflow.ts
import { mastra } from "./mastra";

async function runContentWorkflow() {
  console.log("üöÄ Running workflow programmatically...\n");

  try {
    // Get the workflow instance
    const workflow = mastra.getWorkflow("contentWorkflow");

    if (!workflow) {
      throw new Error("Workflow not found");
    }

    // Create a run instance
    const run = await workflow.createRun();

    // Execute with test data
    const result = await run.start({
      inputData: {
        content:
          "Climate change is one of the most pressing challenges of our time, requiring immediate action from governments, businesses, and individuals worldwide.",
        type: "blog",
      },
    });

    if (result.status === "success") {
      console.log("‚úÖ Success!");
      console.log(
        "üìä Reading time:",
        result.result.metadata.readingTime,
        "minutes",
      );
      console.log("üéØ Difficulty:", result.result.metadata.difficulty);
      console.log("üìÖ Processed at:", result.result.metadata.processedAt);
    }
  } catch (error) {
    console.error("‚ùå Error:", (error as Error).message);
  }
}

// Run the workflow
runContentWorkflow();
```

## Running the Code

Execute your workflow runner:

```bash
npx tsx src/run-workflow.ts
```

## Key Methods

- **`mastra.getWorkflow(id)`**: Gets a registered workflow by ID
- **`workflow.createRun()`**: Creates a new execution instance
- **`run.start(inputData)`**: Executes the workflow with provided data

## Return Value

The `start()` method returns:

- **`success`**: Boolean indicating if workflow completed successfully
- **`result`**: The final output from the workflow
- **`executionTime`**: How long the workflow took to run

Your workflow can now be run from anywhere in your application! Next, you'll learn about error handling.

## Step Quiz
**Questions**
1) What do you get back when you run a workflow programmatically?
**Answers**
1) A run result containing status and the workflow outputs.

<!-- STEP:09 -->
## Step 09: Adding a Third Step

# Adding a Third Step

Let's extend your workflow by adding a third step that generates a summary of the content.

## Creating the Summary Step

Add this new step to your workflow file:

```typescript
const generateSummaryStep = createStep({
  id: "generate-summary",
  description: "Creates a summary of the content",
  inputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    metadata: z.object({
      readingTime: z.number(),
      difficulty: z.enum(["easy", "medium", "hard"]),
      processedAt: z.string(),
    }),
  }),
  outputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    metadata: z.object({
      readingTime: z.number(),
      difficulty: z.enum(["easy", "medium", "hard"]),
      processedAt: z.string(),
    }),
    summary: z.string(),
  }),
  execute: async ({ inputData }) => {
    const { content, type, wordCount, metadata } = inputData;

    // Create a simple summary from first sentence
    const sentences = content
      .split(/[.!?]+/)
      .filter((s) => s.trim().length > 0);
    const firstSentence = sentences[0]?.trim() + ".";

    // Generate summary based on content length
    let summary = firstSentence;
    if (wordCount > 50) {
      summary += ` This ${type} contains ${wordCount} words and takes approximately ${metadata.readingTime} minute(s) to read.`;
    }

    console.log(`üìù Generated summary: ${summary.length} characters`);

    return {
      content,
      type,
      wordCount,
      metadata,
      summary,
    };
  },
});
```

## Understanding the Pattern

Notice how this step:

- Takes the output from the previous step as input
- Adds new data (`summary`) while preserving existing data
- Follows the same structure as other steps

Your third step is ready! Next, you'll update the workflow to include all three steps.

## Step Quiz
**Questions**
1) What does the summary step add to the workflow output?
**Answers**
1) A generated summary of the content.

<!-- STEP:10 -->
## Step 10: Updating the Workflow

# Updating the Workflow

Now you'll update your workflow to include all three steps: validate, enhance, and summarize.

## Updating the Workflow Definition

Replace your existing workflow with this updated version:

```typescript
export const contentWorkflow = createWorkflow({
  id: "content-processing-workflow",
  description: "Validates, enhances, and summarizes content",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    metadata: z.object({
      readingTime: z.number(),
      difficulty: z.enum(["easy", "medium", "hard"]),
      processedAt: z.string(),
    }),
    summary: z.string(),
  }),
})
  .then(validateContentStep)
  .then(enhanceContentStep)
  .then(generateSummaryStep)
  .commit();
```

## What Changed

- **Description**: Updated to reflect the new functionality
- **Output Schema**: Now includes the `summary` field
- **Steps**: Added the third step to the chain

## Testing the Updated Workflow

You can now test this workflow in the playground to validate it works as expected.

## The Complete Flow

Your workflow now:

1. **Validates** content and counts words
2. **Enhances** with metadata like reading time and difficulty
3. **Summarizes** the content for quick understanding

Each step builds on the previous one, creating a comprehensive content processing pipeline!

Next, you'll learn about using workflows with agents.

## Step Quiz
**Questions**
1) What changed after updating the workflow?
**Answers**
1) The output schema now includes the summary field and related data.

<!-- STEP:11 -->
## Step 11: Creating an AI Agent

# Creating an AI Agent

Learn how to create an Mastra agent that can be used within your workflows for more intelligent content processing.

## Creating a Content Analysis Agent

Create a new file for your agent in the `src/mastra/agents` directory. Use `content-agent.ts` as the name of the file with the following contents:

```typescript
// src/mastra/agents/content-agent.ts
import { Agent } from "@mastra/core/agent";

export const contentAgent = new Agent({
  name: "Content Agent",
  description: "AI agent for analyzing and improving content",
  instructions: `
    You are a professional content analyst. Your role is to:
    1. Analyze content for clarity and engagement
    2. Identify the main themes and topics
    3. Provide a quality score from 1-10
    4. Suggest specific improvements
    
    Always provide constructive, actionable feedback.
  `,
  model: "openai/gpt-4.1-mini",
});
```

## Understanding the Agent

- **Name**: Unique identifier for the agent
- **Description**: What the agent does
- **Instructions**: Detailed prompts that guide the AI's behavior
- **Model**: Which AI model to use (GPT-4.1-mini is fast and cost-effective)

## Registering and Testing Your Agent

Open your `src/mastra/index.ts` file and add your agent (you may need to append it to the agents object in the Mastra class):

```typescript
// Import your workflow
import { contentAgent } from "./agents/content-agent";

export const mastra = new Mastra({
  // Register your agent here
  agents: {
    contentAgent,
  },
  // ...Existing code
});
```

You can test this agent in the Playground by navigating to the Agents tab and selecting `content-agent`. Use the chat interface to validate the agent is working.

The agent should provide analysis of the content, including themes, quality assessment, and improvement suggestions.

## Why Use Agents in Workflows?

Agents add intelligence to workflows by:

- **Understanding context**: AI can interpret meaning, not just process data
- **Generating insights**: Provide analysis that simple logic cannot
- **Adapting responses**: Give different feedback based on content type
- **Natural language output**: Communicate results in human-readable form

Your AI agent is ready! Next, you'll learn how to integrate it into a workflow step.

## Step Quiz
**Questions**
1) Why introduce an AI agent into the workflow?
**Answers**
1) To provide model-based analysis as part of the pipeline.

<!-- STEP:12 -->
## Step 12: Using Agent in Workflow

# Using Agent in Workflow

Now you'll create a workflow step that uses your AI agent to provide intelligent content analysis.

In each step, in the execute function, you have access to the `mastra` class which provides you the ability to access Agents, Tools, and even other Workflows. In this case, we use the `mastra` class to get our agent and call that agent's `generate()` function.

## Creating an AI Analysis Step

Add this step to your workflow file:

```typescript
const aiAnalysisStep = createStep({
  id: "ai-analysis",
  description: "AI-powered content analysis",
  inputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    metadata: z.object({
      readingTime: z.number(),
      difficulty: z.enum(["easy", "medium", "hard"]),
      processedAt: z.string(),
    }),
    summary: z.string(),
  }),
  outputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    metadata: z.object({
      readingTime: z.number(),
      difficulty: z.enum(["easy", "medium", "hard"]),
      processedAt: z.string(),
    }),
    summary: z.string(),
    aiAnalysis: z.object({
      score: z.number(),
      feedback: z.string(),
    }),
  }),
  execute: async ({ inputData, mastra }) => {
    const { content, type, wordCount, metadata, summary } = inputData;

    // Create prompt for the AI agent
    const prompt = `
Analyze this ${type} content:

Content: "${content}"
Word count: ${wordCount}
Reading time: ${metadata.readingTime} minutes
Difficulty: ${metadata.difficulty}

Please provide:
1. A quality score from 1-10
2. Brief feedback on strengths and areas for improvement

Format as JSON: {"score": number, "feedback": "your feedback here"}
    `;

    // Get the contentAgent from the mastra instance.
    const contentAgent = mastra.getAgent("contentAgent");
    const { text } = await contentAgent.generate([
      { role: "user", content: prompt },
    ]);

    // Parse AI response (with fallback)
    let aiAnalysis;
    try {
      aiAnalysis = JSON.parse(text);
    } catch {
      aiAnalysis = {
        score: 7,
        feedback: "AI analysis completed. " + text,
      };
    }

    console.log(`ü§ñ AI Score: ${aiAnalysis.score}/10`);

    return {
      content,
      type,
      wordCount,
      metadata,
      summary,
      aiAnalysis,
    };
  },
});
```

Your agent-powered step is ready! Next, you'll add it to your workflow for complete AI-enhanced content processing.

## Step Quiz
**Questions**
1) What does the AI analysis step output?
**Answers**
1) An aiAnalysis object with a score and feedback.

<!-- STEP:13 -->
## Step 13: Creating AI-Enhanced Workflow

# Creating AI-Enhanced Workflow

Now you'll create a new workflow that includes agent analysis alongside your existing content processing steps.

## Creating the Enhanced Workflow

Add this new workflow to your file:

```typescript
export const aiContentWorkflow = createWorkflow({
  id: "ai-content-workflow",
  description: "AI-enhanced content processing with analysis",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    content: z.string(),
    type: z.string(),
    wordCount: z.number(),
    metadata: z.object({
      readingTime: z.number(),
      difficulty: z.enum(["easy", "medium", "hard"]),
      processedAt: z.string(),
    }),
    summary: z.string(),
    aiAnalysis: z.object({
      score: z.number(),
      feedback: z.string(),
    }),
  }),
})
  .then(validateContentStep)
  .then(enhanceContentStep)
  .then(generateSummaryStep)
  .then(aiAnalysisStep)
  .commit();
```

## Registering the New Workflow

Update your Mastra configuration to include both workflows and ensure the contentAgent has been added.

```typescript
// In src/mastra/index.ts
import {
  contentWorkflow,
  aiContentWorkflow,
} from "./workflows/content-workflow";
import { contentAgent } from "./agents/content-agent";

export const mastra = new Mastra({
  workflows: {
    contentWorkflow,
    aiContentWorkflow, // Add the AI-enhanced version
  },
  agents: { contentAgent },
  // ... rest of configuration
});
```

## Testing the Agent-Enhanced Workflow

You can now access this new Workflow inside the Mastra playground. Select this new `ai-content-workflow` workflow from the Workflows tab and run a test to validate it works as expected.

## The Complete AI Pipeline

Your AI-enhanced workflow now:

1. **Validates** content and counts words
2. **Enhances** with metadata
3. **Summarizes** the content
4. **Analyzes** with AI for quality scoring and feedback

This creates a comprehensive, AI-powered content processing system! Next, you'll learn about parallel execution.

## Step Quiz
**Questions**
1) What distinguishes the AI-enhanced workflow from the original?
**Answers**
1) It includes the AI analysis step and outputs aiAnalysis data.

<!-- STEP:14 -->
## Step 14: Understanding Parallel Execution

# Understanding Parallel Execution

Learn how to run multiple workflow steps simultaneously to improve performance when steps don't depend on each other.

## When to Use Parallel Execution

Use parallel execution when you have steps that:

- **Don't depend on each other**: Can run independently
- **Take time**: Network requests, AI calls, or heavy computations
- **Process the same input**: Multiple analyses of the same data

## Example Scenario

Imagine you want to analyze content in three different ways:

1. SEO analysis
2. Readability analysis
3. Sentiment analysis

These can all run at the same time since they don't depend on each other!

## Creating Parallel Steps

The .parallel() method on a workflow executes multiple steps in parallel.

```typescript
workflow.parallel([stepOne, stepTwo]);
```

## Performance Benefits

Running steps in parallel:

- **Faster execution**: Steps run simultaneously instead of waiting
- **Improved user experience**: Shorter wait times

Next, you'll create the other parallel steps and see how to combine them!

## Step Quiz
**Questions**
1) When should you use parallel execution?
**Answers**
1) When independent analyses can run concurrently to reduce latency.

<!-- STEP:15 -->
## Step 15: Creating Parallel Steps

# Creating Parallel Steps

Let's create three analysis steps that can run simultaneously to analyze different aspects of content.

## Creating the Analysis Steps

Add these three steps to your workflow file:

```typescript
// SEO Analysis
const seoAnalysisStep = createStep({
  id: "seo-analysis",
  description: "SEO optimization analysis",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    seoScore: z.number(),
    keywords: z.array(z.string()),
  }),
  execute: async ({ inputData }) => {
    console.log("üîç Running SEO analysis...");
    await new Promise((resolve) => setTimeout(resolve, 800));

    const words = inputData.content.toLowerCase().split(/\s+/);
    const keywords = words.filter((word) => word.length > 4).slice(0, 3);

    return {
      seoScore: Math.floor(Math.random() * 40) + 60,
      keywords,
    };
  },
});

// Readability Analysis
const readabilityStep = createStep({
  id: "readability-analysis",
  description: "Content readability analysis",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    readabilityScore: z.number(),
    gradeLevel: z.string(),
  }),
  execute: async ({ inputData }) => {
    console.log("üìñ Running readability analysis...");
    await new Promise((resolve) => setTimeout(resolve, 600));

    const sentences = inputData.content.split(/[.!?]+/).length;
    const words = inputData.content.split(/\s+/).length;
    const avgWordsPerSentence = words / sentences;

    const score = Math.max(0, 100 - avgWordsPerSentence * 3);
    const gradeLevel = score > 80 ? "Easy" : score > 60 ? "Medium" : "Hard";

    return {
      readabilityScore: Math.floor(score),
      gradeLevel,
    };
  },
});

// Sentiment Analysis
const sentimentStep = createStep({
  id: "sentiment-analysis",
  description: "Content sentiment analysis",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    sentiment: z.enum(["positive", "neutral", "negative"]),
    confidence: z.number(),
  }),
  execute: async ({ inputData }) => {
    console.log("üòä Running sentiment analysis...");
    await new Promise((resolve) => setTimeout(resolve, 700));

    const content = inputData.content.toLowerCase();
    const positiveWords = ["good", "great", "excellent", "amazing"];
    const negativeWords = ["bad", "terrible", "awful", "horrible"];

    const positive = positiveWords.filter((word) =>
      content.includes(word),
    ).length;
    const negative = negativeWords.filter((word) =>
      content.includes(word),
    ).length;

    let sentiment: "positive" | "neutral" | "negative" = "neutral";
    if (positive > negative) sentiment = "positive";
    if (negative > positive) sentiment = "negative";

    return {
      sentiment,
      confidence: Math.random() * 0.3 + 0.7, // 0.7-1.0
    };
  },
});
```

## Notice the Timing

Each step has a different simulated processing time:

- SEO: 800ms
- Readability: 600ms
- Sentiment: 700ms

When run sequentially, total time would be ~2.2 seconds. When run in parallel, total time will be ~800ms (the longest step)!

Next, you'll learn how to run these steps in parallel using the `.parallel()` method.

## Step Quiz
**Questions**
1) What do the parallel analysis steps compute?
**Answers**
1) SEO score/keywords, readability score/grade level, and sentiment.

<!-- STEP:16 -->
## Step 16: Building Parallel Workflow

# Building Parallel Workflow

Now you'll create a workflow that runs your analysis steps in parallel for maximum performance.

## Creating the Parallel Workflow

Add this workflow to your file:

```typescript
export const parallelAnalysisWorkflow = createWorkflow({
  id: "parallel-analysis-workflow",
  description: "Run multiple content analyses in parallel",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    results: z.object({
      seo: z.object({
        seoScore: z.number(),
        keywords: z.array(z.string()),
      }),
      readability: z.object({
        readabilityScore: z.number(),
        gradeLevel: z.string(),
      }),
      sentiment: z.object({
        sentiment: z.enum(["positive", "neutral", "negative"]),
        confidence: z.number(),
      }),
    }),
  }),
})
  .parallel([seoAnalysisStep, readabilityStep, sentimentStep])
  .then(
    createStep({
      id: "combine-results",
      description: "Combines parallel analysis results",
      inputSchema: z.object({
        "seo-analysis": z.object({
          seoScore: z.number(),
          keywords: z.array(z.string()),
        }),
        "readability-analysis": z.object({
          readabilityScore: z.number(),
          gradeLevel: z.string(),
        }),
        "sentiment-analysis": z.object({
          sentiment: z.enum(["positive", "neutral", "negative"]),
          confidence: z.number(),
        }),
      }),
      outputSchema: z.object({
        results: z.object({
          seo: z.object({
            seoScore: z.number(),
            keywords: z.array(z.string()),
          }),
          readability: z.object({
            readabilityScore: z.number(),
            gradeLevel: z.string(),
          }),
          sentiment: z.object({
            sentiment: z.enum(["positive", "neutral", "negative"]),
            confidence: z.number(),
          }),
        }),
      }),
      execute: async ({ inputData }) => {
        console.log("üîÑ Combining parallel results...");

        return {
          results: {
            seo: inputData["seo-analysis"],
            readability: inputData["readability-analysis"],
            sentiment: inputData["sentiment-analysis"],
          },
        };
      },
    }),
  )
  .commit();
```

## Understanding Parallel Data Flow

When steps run in parallel:

1. Each step receives the same input data
2. Steps execute simultaneously
3. Results are collected into an object with step IDs as keys
4. The next step receives all parallel results

## Key Points

- **`.parallel([step1, step2, step3])`**: Runs all steps simultaneously
- **Result object keys**: Use the step IDs (e.g., "seo-analysis")
- **Combine step**: Processes all parallel results together

Next, you'll test this parallel workflow and see the performance improvement!

## Step Quiz
**Questions**
1) What does the parallel workflow aggregate?
**Answers**
1) Results from multiple analysis steps into a combined output object.

<!-- STEP:17 -->
## Step 17: Testing Parallel Workflow

# Testing Parallel Workflow

Let's test your parallel workflow.

## Registering the New Workflow

Update your Mastra configuration to include your new workflow workflows:

```typescript
// In src/mastra/index.ts
import {
  contentWorkflow,
  aiContentWorkflow,
  parallelAnalysisWorkflow,
} from "./workflows/content-workflow";

export const mastra = new Mastra({
  workflows: {
    contentWorkflow,
    aiContentWorkflow,
    parallelAnalysisWorkflow, // Add the parallel workflow
  },
  // ... rest of configuration
});
```

## Testing the Parallel Workflow

You can now test this new workflow in the Playground. You will notice that it processes the three analysis steps in parallel speeding up execution time.

## When to Use Parallel Execution

Use parallel execution when:

- Steps don't depend on each other's outputs
- Steps involve I/O operations (API calls, database queries)
- You want to maximize performance
- Steps process the same input data

Register your parallel workflow with Mastra to use it in the playground! Next, you'll learn about conditional branching.

## Step Quiz
**Questions**
1) What is the goal of testing the parallel workflow?
**Answers**
1) To confirm all parallel steps run and return aggregated results.

<!-- STEP:18 -->
## Step 18: Understanding Conditional Branching

# Understanding Conditional Branching

Learn how to create workflows that take different paths based on data conditions, making your workflows more intelligent and adaptive.

## What is Conditional Branching?

Conditional branching allows workflows to:

- **Make decisions**: Choose different processing paths based on data
- **Handle variations**: Process different content types differently
- **Optimize performance**: Skip unnecessary steps for certain inputs
- **Customize behavior**: Provide different experiences based on conditions

## Real-World Example

Imagine a content processing workflow that:

- **Short content** (< 50 words): Gets quick processing
- **Medium content** (50-200 words): Gets standard processing
- **Long content** (> 200 words): Gets detailed processing with extra analysis

## Basic Branching Syntax

```typescript
.branch([
  [condition1, step1],
  [condition2, step2],
  [condition3, step3]
])
```

Where:

- **condition**: An async function that returns `true` or `false`
- **step**: The step to execute if the condition is `true`

## Condition Functions

Conditions are functions that examine the input data:

```typescript
// Example condition function
async ({ inputData }) => {
  return inputData.wordCount < 50;
};
```

## Multiple Paths

- If multiple conditions are `true`, **all matching steps run in parallel**
- If no conditions are `true`, the workflow continues without executing any branch steps
- Conditions are evaluated in order, but matching steps run simultaneously

## Benefits

- **Smart routing**: Send data down the most appropriate path
- **Performance**: Skip expensive operations when not needed
- **Flexibility**: Handle different scenarios in one workflow
- **Maintainability**: Clear logic for different processing paths

Next, you'll create a workflow with conditional branches!

## Step Quiz
**Questions**
1) What does conditional branching enable in workflows?
**Answers**
1) Different processing paths based on runtime conditions.

<!-- STEP:19 -->
## Step 19: Creating Conditional Steps

# Creating Conditional Steps

Let's create two processing steps for different types of content: one for short and simple content, and one for everything else.

## Assessment Step

First, create a step that analyzes content to determine which path to take:

```typescript
const assessContentStep = createStep({
  id: "assess-content",
  description: "Assesses content to determine processing path",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
    wordCount: z.number(),
    complexity: z.enum(["simple", "moderate", "complex"]),
    category: z.enum(["short", "medium", "long"]),
  }),
  execute: async ({ inputData }) => {
    const { content, type } = inputData;
    const words = content.trim().split(/\s+/);
    const wordCount = words.length;

    // Determine category by length
    let category: "short" | "medium" | "long" = "short";
    if (wordCount >= 50) category = "medium";
    if (wordCount >= 200) category = "long";

    // Determine complexity by average word length
    const avgWordLength =
      words.reduce((sum, word) => sum + word.length, 0) / wordCount;
    let complexity: "simple" | "moderate" | "complex" = "simple";
    if (avgWordLength > 5) complexity = "moderate";
    if (avgWordLength > 7) complexity = "complex";

    console.log(`üìã Assessment: ${category} content, ${complexity} complexity`);

    return {
      content,
      type,
      wordCount,
      complexity,
      category,
    };
  },
});
```

## Quick Processing Step

For short, simple content:

```typescript
const quickProcessingStep = createStep({
  id: "quick-processing",
  description: "Quick processing for short and simple content",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
    wordCount: z.number(),
    complexity: z.enum(["simple", "moderate", "complex"]),
    category: z.enum(["short", "medium", "long"]),
  }),
  outputSchema: z.object({
    processedContent: z.string(),
    processingType: z.string(),
    recommendations: z.array(z.string()),
  }),
  execute: async ({ inputData }) => {
    console.log("‚ö° Quick processing for short and simple content...");

    return {
      processedContent: inputData.content,
      processingType: "quick",
      recommendations: [
        "Content is concise",
        "Consider expanding for more detail",
      ],
    };
  },
});
```

## General Processing Step

For all other content (not short and simple):

```typescript
const generalProcessingStep = createStep({
  id: "general-processing",
  description: "General processing for all other content",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
    wordCount: z.number(),
    complexity: z.enum(["simple", "moderate", "complex"]),
    category: z.enum(["short", "medium", "long"]),
  }),
  outputSchema: z.object({
    processedContent: z.string(),
    processingType: z.string(),
    recommendations: z.array(z.string()),
  }),
  execute: async ({ inputData }) => {
    console.log("üìù General processing for non-short/simple content...");

    // Simulate more involved processing
    await new Promise((resolve) => setTimeout(resolve, 500));

    return {
      processedContent: inputData.content,
      processingType: "general",
      recommendations: [
        "Consider simplifying content",
        "Break up long paragraphs",
        "Add examples or explanations if needed",
      ],
    };
  },
});
```

These two steps will be used in different branches based on the content assessment. Next, you'll create the conditional workflow!

## Step Quiz
**Questions**
1) What does the assessment step decide?
**Answers**
1) Content complexity/category to choose the processing path.

<!-- STEP:20 -->
## Step 20: Building Conditional Workflow

# Building Conditional Workflow

Now you'll create a workflow that uses conditional branching to route content through two different processing paths.

## Creating the Conditional Workflow

Add this workflow to your file:

```typescript
export const conditionalWorkflow = createWorkflow({
  id: "conditional-workflow",
  description: "Content processing with conditional branching",
  inputSchema: z.object({
    content: z.string(),
    type: z.enum(["article", "blog", "social"]).default("article"),
  }),
  outputSchema: z.object({
    processedContent: z.string(),
    processingType: z.string(),
    recommendations: z.array(z.string()),
  }),
})
  .then(assessContentStep)
  .branch([
    // Branch 1: Short and simple content
    [
      async ({ inputData }) =>
        inputData.category === "short" && inputData.complexity === "simple",
      quickProcessingStep,
    ],
    // Branch 2: Everything else
    [
      async ({ inputData }) =>
        !(inputData.category === "short" && inputData.complexity === "simple"),
      generalProcessingStep,
    ],
  ])
  .commit();
```

## Understanding the Conditions

1. **Short + Simple**: Quick processing with minimal recommendations
2. **Everything Else**: General processing with more suggestions

## Multiple Conditions

You can combine conditions using logical operators:

- **`&&`**: AND - both conditions must be true
- **`||`**: OR - either condition can be true
- **`!`**: NOT - condition must be false

## Condition Evaluation

- Conditions are checked in order
- Multiple conditions can be true (steps run in parallel)
- If no conditions match, the branch is skipped

Next, you'll test this conditional workflow with different types of content!

## Step Quiz
**Questions**
1) What is the outcome of the conditional workflow?
**Answers**
1) Processed content with a processingType and recommendations.

<!-- STEP:21 -->
## Step 21: Testing Conditional Logic

# Testing Conditional Logic

Let's test your conditional workflow with different types of content to see how it routes to different processing paths.

## Registering the New Workflow

Update your Mastra configuration to include your new workflow workflows:

```typescript
// In src/mastra/index.ts
import {
  contentWorkflow,
  aiContentWorkflow,
  parallelAnalysisWorkflow,
  conditionalWorkflow,
} from "./workflows/content-workflow";

export const mastra = new Mastra({
  workflows: {
    contentWorkflow,
    aiContentWorkflow,
    parallelAnalysisWorkflow,
    conditionalWorkflow, // Add the conditional workflow
  },
  // ... rest of configuration
});
```

## Testing the conditional workflow

You can now test this new conditional workflow in the playground. Be sure to test different content lengths and content types.

## Understanding the Flow

1. **Assessment step** analyzes content and determines category/complexity
2. **Branch conditions** are evaluated against the assessment results
3. **Matching step** executes based on which condition(s) are true
4. **Results** show which processing path was taken

## Debugging Conditions

If a condition isn't working as expected:

- Check the assessment step output
- Verify condition logic matches your expectations
- Test individual conditions in isolation
- Add console.log statements to track condition evaluation

## Branch Benefits

Conditional workflows provide:

- **Intelligent routing**: Right processing for right content
- **Performance optimization**: Skip heavy processing for simple content
- **Customized experience**: Different handling for different scenarios
- **Scalable logic**: Easy to add new conditions and processing paths

Next, you'll learn about streaming workflow results for better user experience!

## Step Quiz
**Questions**
1) What should you verify when testing conditional logic?
**Answers**
1) That the correct branch is selected for each input case.

<!-- STEP:22 -->
## Step 22: Conclusion

# Conclusion

Congratulations! You've completed the Mastra Workflows course and learned how to build powerful, type-safe workflows that can handle complex automation tasks.

## What You've Accomplished

Throughout this course, you've learned to:

### Core Concepts

- **Understanding workflows**: How they break complex tasks into manageable steps
- **Creating steps**: Building reusable units with clear inputs and outputs
- **Schema validation**: Using Zod for type safety and runtime validation
- **Error handling**: Making workflows robust and user-friendly

### Building Workflows

- **Chaining steps**: Connecting steps to create complete workflows
- **Testing thoroughly**: Ensuring reliability with comprehensive tests
- **Registering with Mastra**: Integrating workflows into your application
- **Using the playground**: Visual testing and debugging

### Advanced Features

- **AI integration**: Combining workflows with agents for intelligent processing
- **Parallel execution**: Running multiple steps simultaneously for better performance
- **Conditional branching**: Creating smart workflows that adapt to different scenarios

## Key Workflows You Built

1. **Content Processing Workflow**: Validates, enhances, and summarizes content
2. **AI-Enhanced Workflow**: Adds intelligent analysis with AI agents
3. **Parallel Analysis Workflow**: Demonstrates high-performance parallel execution
4. **Conditional Workflow**: Shows intelligent routing based on content characteristics

## Next Steps

Now that you understand workflows, you can:

### Expand Your Skills

- **Explore more integrations**: Connect workflows with databases, APIs, and external services
- **Build complex automations**: Create multi-step business processes
- **Integrate with web applications**: Use workflows in your frontend applications
- **Scale for production**: Deploy workflows with proper monitoring and error handling

## Final Thoughts

Workflows are a powerful way to build reliable, maintainable automation systems. The patterns and principles you've learned in this course will help you tackle increasingly complex challenges as you build AI-powered applications.

Remember:

- **Start simple**: Begin with basic workflows and add complexity gradually
- **Test thoroughly**: Good testing prevents production issues
- **Think in steps**: Break complex problems into smaller, manageable pieces
- **Embrace type safety**: Let schemas catch errors early

Thank you for completing the Mastra Workflows lesson. Happy building! üöÄ

## Step Quiz
**Questions**
1) What is the overall takeaway from the conclusion?
**Answers**
1) You can build reliable workflows with steps, agents, parallelism, and branching.
