---
lesson_id: "01-first-agent"
lesson_title: "First Agent"
source_dir: "reference-course/mastra/01-first-agent"
step_count: 18
---

<!-- STEP:01 -->
## Step 01: Getting Started with Mastra

# Getting Started with Mastra

Welcome to the first step of building your first Mastra agent! In this lesson, you'll learn how to create a simple agent that can read data from a public Google Sheet using a custom tool function.

## What is an Agent?

An agent is software with non-deterministic code that can make autonomous decisions based on inputs and environment rather than following fixed, predictable instructions every time.

Agents are AI systems that can:

- Perceive their environment through various inputs
- Make decisions based on those inputs
- Take actions to accomplish specific goals
- Learn and adapt their behavior over time

The best agents use several important features:

1. **Memory**: They remember past interactions and learn from them
2. **Planning**: They can break down complex tasks into smaller steps
3. **Tool use**: They can leverage external tools and APIs to expand their capabilities
4. **Feedback loops**: They can evaluate their own performance and adjust accordingly

## Step Quiz
**Questions**
1) What is the defining characteristic of an agent compared to a fixed script?
**Answers**
1) It makes autonomous decisions based on inputs and environment rather than following a fixed sequence.

<!-- STEP:02 -->
## Step 02: What is Mastra?

# What is Mastra?

[Mastra](https://github.com/mastra-ai/mastra) is an open-source AI Agent Framework for TypeScript that includes all the basic primitives for AI engineering right out of the box:

- Agents with tools, memory, and tracing
- State-machine based workflows
- Evals for tracking and measuring AI output
- Storage for RAG pipelines
- Local development playground

With Mastra, you can quickly build, test, and deploy AI agents that can perform a wide variety of tasks. The framework is designed to be modular and extensible, allowing you to add new capabilities as needed.

## Step Quiz
**Questions**
1) Name two core primitives Mastra provides out of the box.
**Answers**
1) Agents with tools/memory/tracing, workflows, evals, or storage for RAG (any two).

<!-- STEP:03 -->
## Step 03: Verifying Your Mastra Installation

# Verifying Your Mastra Installation

Before we begin building our agent, let's make sure you have the right development environment set up. Let's check if you have Node.js 18.x or later installed.

Then, let's check if @mastra/core is in the package.json and there is a src/mastra directory. If so, you can skip this step.

If you haven't installed Mastra yet, you can do so by running:

```bash
npm -y create mastra@beta
```

If you do need to install mastra, follow the on-screen prompts and make sure to:

- Opt-in to installing both Agents and Workflows
- Say yes to installing tools
- Select OpenAI, Anthropic, or Google for your model
- Say yes to adding an example

You'll also need to add your OpenAI, Anthropic, or Google API key to the project.

## Step Quiz
**Questions**
1) What two checks determine whether you can skip Mastra installation in this step?
**Answers**
1) Node.js 18+ is installed and the project already has @mastra/core plus a src/mastra directory.

<!-- STEP:04 -->
## Step 04: Verifying Project Structure

# Verifying Project Structure

Let's check that your project has the correct structure. You should have:

1. A `src/mastra` directory that contains:
   - `index.ts` - The main entry point for your Mastra project
   - `agents/` - Directory containing individual agent files
   - `tools/` - Directory containing individual tool files
   - `workflows/` - Directory containing individual workflow files

If the CLI created your project, you should see files like:

- `agents/weather-agent.ts` - Example weather agent
- `tools/weather-tool.ts` - Example weather tool
- `workflows/weather-workflow.ts` - Example weather workflow

This structure is important because it follows the Mastra convention for organizing your code. The `index.ts` file is the main entry point for your Mastra project, while the `agents` and `tools` directories contain the definitions for your agents and tools, respectively.

## Step Quiz
**Questions**
1) Which directories are expected inside src/mastra and why do they matter?
**Answers**
1) agents/, tools/, workflows/ (plus index.ts) to follow Mastra conventions for agent/tool/workflow definitions.

<!-- STEP:05 -->
## Step 05: Running Mastra Studio

# Running Mastra Studio

To test your agent as you build it, you'll need to run the Mastra Studio:

```bash
npm run dev
```

This will start the studio at `http://localhost:4111`, where you can interact with your agent and test its capabilities.

The studio provides a user-friendly interface for testing your agent, allowing you to:

- Send messages to your agent
- See the agent's responses
- View the agent's thought process
- Test tools directly
- Debug any issues that arise

In the next step, we'll create our first agent with a simple system prompt and test it in the studio.

## Step Quiz
**Questions**
1) What is Mastra Studio used for during development?
**Answers**
1) It provides a local UI to run and test agents, inspect responses, and debug tools.

<!-- STEP:06 -->
## Step 06: Understanding System Prompts

# Understanding System Prompts

A good system prompt is crucial as it defines your agent's purpose, capabilities, and behavioral guidelines. It's the foundation that shapes how your agent will interact with users.

A well-crafted system prompt should include:

- **Role definition**: What the agent is and what it does
- **Core capabilities**: What tasks the agent can perform
- **Behavioral guidelines**: How the agent should respond and interact
- **Constraints**: What the agent should not do or discuss
- **Success criteria**: What makes the agent's responses good

The system prompt acts as a set of instructions that guide the agent's behavior. It helps the agent understand its purpose and how it should interact with users. A clear and comprehensive system prompt will result in more consistent and helpful agent responses.

## Step Quiz
**Questions**
1) List two elements that should appear in a high-quality system prompt.
**Answers**
1) Role definition, core capabilities, behavioral guidelines, constraints, or success criteria (any two).

<!-- STEP:07 -->
## Step 07: Creating Your Agent

# Creating Your Agent

Let's create a simple agent that will help users analyze financial transaction data. We'll create a new file called `agents/financial-agent.ts`.

First, create the new agent file at src/mastra/agents/financial-agent.ts

Now add the necessary imports at the top of your file:

```typescript
import { Agent } from "@mastra/core/agent";
// We'll import our tool in a later step
```

Now, let's create our agent:

```typescript
export const financialAgent = new Agent({
  name: "Financial Assistant Agent",
  instructions: `ROLE DEFINITION
- You are a financial assistant that helps users analyze their transaction data.
- Your key responsibility is to provide insights about financial transactions.
- Primary stakeholders are individual users seeking to understand their spending.

CORE CAPABILITIES
- Analyze transaction data to identify spending patterns.
- Answer questions about specific transactions or vendors.
- Provide basic summaries of spending by category or time period.

BEHAVIORAL GUIDELINES
- Maintain a professional and friendly communication style.
- Keep responses concise but informative.
- Always clarify if you need more information to answer a question.
- Format currency values appropriately.
- Ensure user privacy and data security.

CONSTRAINTS & BOUNDARIES
- Do not provide financial investment advice.
- Avoid discussing topics outside of the transaction data provided.
- Never make assumptions about the user's financial situation beyond what's in the data.

SUCCESS CRITERIA
- Deliver accurate and helpful analysis of transaction data.
- Achieve high user satisfaction through clear and helpful responses.
- Maintain user trust by ensuring data privacy and security.`,
  model: "openai/gpt-4.1-mini",
  tools: {}, // We'll add tools in a later step
});
```

This creates a financial assistant agent with a well-defined system prompt that outlines its role, capabilities, behavioral guidelines, constraints, and success criteria.

## Step Quiz
**Questions**
1) What is the purpose of the financialAgent created in this step?
**Answers**
1) To analyze transaction data and provide spending insights while following defined constraints.

<!-- STEP:08 -->
## Step 08: Exporting Your Agent

# Exporting Your Agent

To make your agent available to the playground, you need to export it through the Mastra class in your `src/mastra/index.ts` file.

First, import the necessary dependencies and your agent:

```typescript
import { Mastra } from "@mastra/core";
import { PinoLogger } from "@mastra/loggers";
import { LibSQLStore } from "@mastra/libsql";
import { financialAgent } from "./agents/financial-agent";

export const mastra = new Mastra({
  agents: {
    financialAgent,
  },
  storage: new LibSQLStore({
    id: "learning-memory-storage",
    url: ":memory:",
  }),
  logger: new PinoLogger({
    name: "Mastra",
    level: "info",
  }),
});
```

This creates a new Mastra instance that includes:

- Your financial agent
- In-memory storage for development
- A logger for debugging and monitoring

The Mastra class is the main entry point for your Mastra project. It's responsible for registering your agents and configuring the core services like storage and logging.

## Step Quiz
**Questions**
1) Why must the agent be exported in src/mastra/index.ts?
**Answers**
1) So Mastra can register it and make it available in the playground/studio.

<!-- STEP:09 -->
## Step 09: Testing Your Agent

# Testing Your Agent

Now let's test our agent in Mastra Studio:

1. Make sure your development server is running with `npm run dev`
2. Open the studio at http://localhost:4111/
3. You should see your "Financial Assistant Agent" in the list of agents
4. Try sending a message like "Hello, can you help me analyze my spending?"

At this point, your agent can respond to basic questions but doesn't have access to any transaction data. In the next step, we'll create a custom tool to fetch transaction data from a Google Sheet.

Testing your agent in the studio is an important step in the development process. It allows you to see how your agent responds to different inputs and identify any issues that need to be addressed before deploying it to production.

## Step Quiz
**Questions**
1) What is the goal of testing the agent at this stage?
**Answers**
1) To verify the prompt behavior and basic responses before adding tools.

<!-- STEP:10 -->
## Step 10: Understanding Tools in Mastra

# Understanding Tools in Mastra

Tools in Mastra are functions that your agent can call to perform specific tasks. They extend your agent's capabilities by giving it access to external data sources, APIs, and functionality beyond what's available in the language model itself.

Each tool has:

- A unique ID that the agent uses to reference it
- A clear description of what it does, which helps the agent understand when to use it
- Input and output schemas that define the expected parameters and return values
- An execute function that performs the actual work

Tools are a powerful way to enhance your agent's abilities. They allow your agent to interact with the outside world, access specific data sources, and perform actions that would otherwise be impossible for a language model alone.

In the next step, we'll create a custom tool that fetches transaction data from a Google Sheet.

## Step Quiz
**Questions**
1) What role do tools play in Mastra agents?
**Answers**
1) They extend the agent with external actions or data access beyond the model itself.

<!-- STEP:11 -->
## Step 11: Creating the getTransactions Tool

# Creating the getTransactions Tool

Let's create a tool that fetches transaction data from a Google Sheet. We'll create a new file called `tools/get-transactions-tool.ts`.

First, create the new tool file at src/mastra/tools/get-transactions-tool.ts

Now add the necessary imports:

```typescript
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
```

Now, let's create our tool:

```typescript
export const getTransactionsTool = createTool({
  id: "get-transactions",
  description: "Get transaction data from Google Sheets",
  inputSchema: z.object({}), // No input parameters needed
  outputSchema: z.object({
    csvData: z.string(),
  }),
  execute: async () => {
    return await getTransactions();
  },
});

const getTransactions = async () => {
  // This URL points to a public Google Sheet with transaction data
  const url =
    "https://docs.google.com/spreadsheets/d/e/2PACX-1vTQWaCzJAFsF4owWRHQRLo4G0-ERv31c74OOZFnqLiTLaP7NweoiX7IXvzQud2H6bdUPnIqZEA485Ux/pub?gid=0&single=true&output=csv";
  const response = await fetch(url);
  const data = await response.text();
  return {
    csvData: data,
  };
};
```

This tool fetches transaction data from a public Google Sheet and returns it as a string. The `createTool` function from Mastra makes it easy to define the tool's ID, description, input and output schemas, and execution logic.

## Step Quiz
**Questions**
1) What does the getTransactions tool return to the agent?
**Answers**
1) It fetches and returns transaction CSV data from a URL.

<!-- STEP:12 -->
## Step 12: Connecting the Tool to Your Agent

# Connecting the Tool to Your Agent

Now that we've created our tool, we need to connect it to our agent. Go back to your `agents/financial-agent.ts` file and update it:

1. Import the tool:

```typescript
import { getTransactionsTool } from "../tools/get-transactions-tool";
```

2. Add the tool to your agent:

```typescript
export const financialAgent = new Agent({
  name: "Financial Assistant Agent",
  instructions: `ROLE DEFINITION
  // ... existing instructions ...
  
  TOOLS
  - Use the getTransactions tool to fetch financial transaction data.
  - Analyze the transaction data to answer user questions about their spending.`,
  model: "openai/gpt-4.1-mini",
  tools: { getTransactionsTool }, // Add our tool here
});
```

By adding the tool to your agent's configuration, you're making it available for the agent to use. The agent will now be able to call the `getTransactions` tool when it needs to access transaction data.

It's also important to update the agent's instructions to include information about the tool. This helps the agent understand when and how to use the tool to fulfill user requests.

## Step Quiz
**Questions**
1) What change connects the tool to the agent?
**Answers**
1) Add the getTransactions tool to the agent's tools map when creating the agent.

<!-- STEP:13 -->
## Step 13: Testing Your Tool

# Testing Your Tool

Let's test our tool and agent in Mastra Studio:

1. Make sure your development server is running with `npm run dev`
2. Open the studio at http://localhost:4111/
3. You can test the tool directly in the Tools tab to make sure it's working
4. Then, try asking your agent questions like:
   - "Can you show me my recent transactions?"
   - "How much did I spend on Amazon?"
   - "What was my largest transaction this month?"

Your agent should now be able to fetch the transaction data and answer questions about it. However, it doesn't yet have memory, so it won't remember previous conversations. We'll add that in the next step.

Testing your tool directly in the studio is a great way to verify that it's working correctly before integrating it with your agent. This helps you identify and fix any issues with the tool itself before troubleshooting potential issues with the agent's use of the tool.

## Step Quiz
**Questions**
1) What is the success signal when testing the tool?
**Answers**
1) The agent can call the tool and respond using the returned transaction data.

<!-- STEP:14 -->
## Step 14: Understanding Memory in Agents

# Understanding Memory in Agents

Memory is a crucial component for creating more natural and context-aware agents. It allows your agent to maintain context across multiple interactions with users.

Memory allows your agent to:

- Remember previous user questions and its own responses
- Maintain context across multiple interactions
- Provide more personalized and relevant responses
- Avoid asking for the same information repeatedly

Without memory, your agent would treat each interaction as if it were the first, leading to a disjointed and frustrating user experience. With memory, your agent can build on previous conversations, creating a more natural and helpful interaction.

In the following steps, we'll add memory to our financial assistant agent to make it more context-aware and capable of providing better responses over time.

## Step Quiz
**Questions**
1) What is the purpose of agent memory in this lesson?
**Answers**
1) To keep context across turns and enable personalized follow-up responses.

<!-- STEP:15 -->
## Step 15: Installing Memory

# Installing Memory

First, we need to install the Mastra memory package to add memory capabilities to our agent. We also install a storage adapter to persist the memory data. We will use the `libsql` storage adapter. Run the following command in your terminal:

```bash
npm install @mastra/memory @mastra/libsql
```

The `@mastra/memory` package provides a simple yet powerful memory system for your Mastra agents. It allows your agent to remember previous conversations and maintain context across multiple interactions.

The `@mastra/libsql` package is one of many storage adapters that persists the memory data to an `SQLite` database.

These packages are separate from the core Mastra package to keep the framework modular and allow you to only include the features you need in your project.

## Step Quiz
**Questions**
1) What do you need to install to enable memory in this project?
**Answers**
1) The memory/storage dependencies used by Mastra (e.g., libsql store) as instructed.

<!-- STEP:16 -->
## Step 16: Adding Memory to Your Agent

# Adding Memory to Your Agent

Now, let's update our agent to include memory. Open your `agents/index.ts` file and make the following changes:

1. Import the Memory and LibSQLStore classes:

```typescript
import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { LibSQLStore } from "@mastra/libsql";
import { getTransactionsTool } from "../tools";
```

2. Add memory to your agent configured by a storage instance:

```typescript
export const financialAgent = new Agent({
  name: "Financial Assistant Agent",
  instructions: `ROLE DEFINITION
  // ... existing instructions ...
  `,
  model: "openai/gpt-4.1-mini",
  tools: { getTransactionsTool },
  memory: new Memory({
    storage: new LibSQLStore({
      id: "learning-memory-storage",
      url: "file:../../memory.db", // local file-system database. Location is relative to the output directory `.mastra/output`
    }),
  }), // Add memory here
});
```

By adding the `memory` property to your agent configuration, you're enabling it to remember previous conversations. The `Memory` class from the `@mastra/memory` package provides a simple way to add memory capabilities to your agent. The `LibSQLStore` class from `@mastra/libsql` persists the memory data to a `SQLite` database.

## Step Quiz
**Questions**
1) What configuration links memory storage to the agent?
**Answers**
1) Add a memory block with a storage adapter (id/url) on the agent configuration.

<!-- STEP:17 -->
## Step 17: Testing Your Agent with Memory

# Testing Your Agent with Memory

Let's test our agent's memory capabilities in Mastra Studio:

1. Make sure your development server is running with `npm run dev`
2. Open the studio at http://localhost:4111/
3. Start a conversation with your agent by asking about transactions
4. Then, ask a follow-up question that references the previous conversation, like:
   - "What was that largest transaction again?"
   - "Can you categorize those Amazon purchases we talked about?"
   - "How does my spending this month compare to what you showed me earlier?"

Your agent should now be able to remember previous conversations and provide more contextual responses.

With memory enabled, your agent can now maintain context across multiple interactions, creating a more natural and helpful user experience. This is especially important for financial assistants, where users may want to refer back to previous information or build on earlier conversations.

## Step Quiz
**Questions**
1) How can you confirm memory is working in the studio?
**Answers**
1) Ask a follow-up question that relies on earlier context and verify the agent recalls it.

<!-- STEP:18 -->
## Step 18: Congratulations!

# Congratulations!

You've successfully built your first Mastra agent with:

- A well-defined system prompt
- A custom tool for fetching transaction data
- Memory for maintaining context across conversations

This is just the beginning of what you can do with Mastra. Here are some ways you could extend your agent:

- Add more tools or use MCP to expand its capabilities (we will cover this in the next lesson)
- Implement more sophisticated memory storage
- Create a workflow that combines multiple agents
- Deploy your agent to a production environment

For more information and advanced features, check out the [Mastra documentation](https://mastra.ai/docs).

## Next Steps

In the next lesson, you'll learn how to integrate MCP (Model Context Protocol) servers with your Mastra agent to expand its capabilities even further. MCP servers allow your agent to access external data sources and APIs, making it even more powerful and versatile.

## Step Quiz
**Questions**
1) What is the next topic to explore after this lesson?
**Answers**
1) Integrating MCP servers to expand agent capabilities.
